{"name":"Deniro4h.GitHub.io","tagline":"L4H 的博客","body":"#@property 指示符\r\n@(object-c)\r\n\r\n###  assign\r\n- 指示符只是简单的赋值，不更改所赋值的引用计数，主要用于 NSInteger 等基本类型\r\n 比如：short    int   float  结构体等C语言等数据类型\r\n    ```\r\n       @property (nonatomic, assign) id className;\r\n       //id必须用assign\r\n \r\n    ```\r\n \r\n------------------------\r\n###atomic 和 nonatomic\r\n\r\n- **autonmic**  ：原子操作，这个是线程安全的，当一个线程进入方法体后，其他先线程不能进入。但是执行效率低。主要用于多线程\r\n-  **nonatomic** ：非原子操作，线程不安全， 当一个线程进入方法体后，其他线程可以进入，会造成数据的不安全，当是效率高，主要用于单线程中\r\n- ------------------------------\r\n###copy\r\n- 当调用set方法对成员变量赋值的时候，会将要被赋值的对象先复制一个副本，然后在将副本赋值给该成员变量，这样的话可以保证成员变量 `不被修改`。引用计数会加1 。\r\n\r\n- 如果没有用copy修饰的话，当成员变量是可变类型的时候或子类是可变类型的话，就可被修改，比如\r\n ```\r\n @proprety（assign）NSString *name；\r\n  \r\n  NSMuTableString str = [NSMuTableString stringWithString:@\"sb，可改变的\"]\r\n  \r\n  [  book setName ：str]\r\n  //当str发生改变的时候 name属性也会跟着一起被改变\r\n  \r\n   ```\r\n \r\n-------------------------------------\r\n\r\n### getter和setter修饰符\r\n\r\n> 用于自定义get和set方法名的\r\n\r\n``` @property(assign, nonmatic, getter = name, setter = age)  ```\r\n\r\n----------------------\r\n###readonly 和 readwrite\r\n-  **readonly** ：只生成get方法，没有set方法\r\n-  **readwrite**：只生成set方法 ，没有get方法\r\n\r\n------------------------\r\n###return\r\n- 主要用于计数应用加1\r\n- 一般是用于字符串（ NSString，NSMutableString），数组（NSMutableArray，NSArray），字典对象，视图对象（UIView ），控制器对象（UIViewController）等 \r\n比如： \r\n@property (nonatomic,retain) NSString * myString; \r\n@property (nonatomic, retain) UIView * myView; \r\n@property (nonatomic, retain) UIViewController * myViewController; \r\n>在使用ARC的情况下常用的指示符：当一个对象引用计数大于1时，该对象不该被回收，当使用ARC的话，一般很少用。\r\n- 启用ARC机制：  - fobjc - arc\r\n\r\n-------------------------------------\r\n###strong和 week\r\n-  **strong** ：强引用，只要指向被赋值的对象，那么该对象就不会被自动回收。\r\n\r\n\r\n-   **week** ：弱引用，弱引用指向的对象，可能被回收。\r\n\r\n>什么时候用：如果不希望该属性的引用的对象被回收的话，用strong，性能低。\r\n>为了保证性能，避免内存泄漏，可以使用week，对应声明为week的指针，指针指向的地址一旦被释放，这些指针都被赋值为nil，能防止出现悬空指针。\r\n\r\n\r\n\r\n- 事实上 （week==assign）（strong==retain）\r\n\r\n>注意：苹果建议使用week代替assign\r\n\r\n####比如 1\r\n\r\n\r\n1  从storyboard或者xib上创建控件，在控件放在view上的时候，已经形成了如下的引用关系,以UIButton为例：\r\nUIViewController->UIView->subView->UIButton然后你为这个UIButton声明一个weak属性  \r\n`@property(nonatomic,weak) IBOOutlet UIButton *btn;`\r\n相当于xib/sb对这个Button是强引用，你声明的属性对它是弱引用。\r\n\r\n2 手动创建控件\r\na). 将控件声明成strong\r\n`@property(nonatomic,strong) UIButton *btn;`\r\n那么你在实现这个控件时只需这样：\r\n\r\n`\r\n_btn = [[UIButton alloc]init];\r\n[self.view addSubview:_btn]\r\n`\r\n\r\nb). 将控件声明成\r\nweak@property(nonatomic,weak) UIButton *btn;\r\n那么你在实现这个控件时需要这样：\r\n\r\n\r\n`\r\nUIButton *button = [[UIButton alloc]init];\r\n_btn = button;\r\n[self.view addSubview:_btn];\r\n`\r\n有一种情况：如果label1添加到button1，label2添加到button1，而self.view addSubView button1,如果当button从父视图移除的话，label1和label2不想消失，那么就得用strong（强引用），而button用不用strong都无所谓，因为界面都消失了，要button有何用。。。。。\r\n\r\n>#####注意：NSString一般用copy ，控件类用week ，复杂类型一般用Strong，基本数据类型（NSInteger，int ，float。。。。。）一般用assign（一般的赋值）\r\n\r\n####比如 2\r\n\r\n```\r\n1>\r\n@property (nonatomic,strong) NSString * str1; \r\n@property (nonatomic,week) NSString * str2; \r\n_str1 = [NSMUtableString alloc]initWithString:@\"杠杠滴\"\r\n_str2 = str1;\r\n_str1 = nil;\r\nNSLog(@\"%@\", str2);\r\n//输出结果为空\r\n\r\n\r\n2>\r\n@property (nonatomic,strong) NSString * str1; \r\n@property (nonatomic,strong) NSString * str2; \r\n_str1 = [NSMUtableString alloc]initWithString:@\"杠杠滴\"\r\n_str2 = str1;\r\n_str1 = nil;\r\nNSLog(@\"%@\", _str2);\r\n//输出结果为:杠杠滴\r\n```\r\n>####解释：\r\n![Alt text](./1450627289258.png)\r\n\r\n> #### ARC原则：只要还有一个变量指向对象，对象就会保持在内存中\r\n> #### 1》week: str2虽然和str1指向同一段内存，但是str2并不是拥有者，所以当str1=nil，内存就被释放了，str2也就等于nil。\r\n> ####2 》strong：str2和str1都指向同一段内存，而且都是拥有者，当str1= nil 释放后，str2仍然指向那块内存，也就是等于@“杠杆的”。\r\n\r\n\r\n-----------------------\r\n###unsafe_unretained\r\n- 和week基本类似，与week不同的是，当unsafe_unretained指针引用的对象被回收后，unsafe_unretained不会被置为nil。\r\n>注： 一般来说，unsafe_unretuained不如week指示符\r\n\r\n\r\n#>待完善。。。。。\r\n\r\n<font color=red>xx</font>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}