<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Deniro4h.GitHub.io by DeNiRo4H</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/DeNiRo4H">View On GitHub</a></li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Deniro4h.GitHub.io</h1>
          <p>L4H 的博客</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/DeNiRo4H">DeNiRo4H</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="property-指示符" class="anchor" href="#property-%E6%8C%87%E7%A4%BA%E7%AC%A6" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="https://github.com/property" class="user-mention">@property</a> 指示符</h1>

<p>@(object-c)</p>

<h3>
<a id="assign" class="anchor" href="#assign" aria-hidden="true"><span class="octicon octicon-link"></span></a>assign</h3>

<ul>
<li>
<p>指示符只是简单的赋值，不更改所赋值的引用计数，主要用于 NSInteger 等基本类型
比如：short    int   float  结构体等C语言等数据类型</p>

<pre><code>     @property (nonatomic, assign) id className;
     //id必须用assign

</code></pre>
</li>
</ul>

<hr>

<h3>
<a id="atomic-和-nonatomic" class="anchor" href="#atomic-%E5%92%8C-nonatomic" aria-hidden="true"><span class="octicon octicon-link"></span></a>atomic 和 nonatomic</h3>

<ul>
<li>
<strong>autonmic</strong>  ：原子操作，这个是线程安全的，当一个线程进入方法体后，其他先线程不能进入。但是执行效率低。主要用于多线程</li>
<li> <strong>nonatomic</strong> ：非原子操作，线程不安全， 当一个线程进入方法体后，其他线程可以进入，会造成数据的不安全，当是效率高，主要用于单线程中
- ------------------------------
###copy</li>
<li><p>当调用set方法对成员变量赋值的时候，会将要被赋值的对象先复制一个副本，然后在将副本赋值给该成员变量，这样的话可以保证成员变量 <code>不被修改</code>。引用计数会加1 。</p></li>
<li>
<p>如果没有用copy修饰的话，当成员变量是可变类型的时候或子类是可变类型的话，就可被修改，比如</p>

<pre><code>@proprety（assign）NSString *name；

NSMuTableString str = [NSMuTableString stringWithString:@"sb，可改变的"]

[  book setName ：str]
//当str发生改变的时候 name属性也会跟着一起被改变

</code></pre>
</li>
</ul>

<hr>

<h3>
<a id="getter和setter修饰符" class="anchor" href="#getter%E5%92%8Csetter%E4%BF%AE%E9%A5%B0%E7%AC%A6" aria-hidden="true"><span class="octicon octicon-link"></span></a>getter和setter修饰符</h3>

<blockquote>
<p>用于自定义get和set方法名的</p>
</blockquote>

<p><code>@property(assign, nonmatic, getter = name, setter = age)</code></p>

<hr>

<h3>
<a id="readonly-和-readwrite" class="anchor" href="#readonly-%E5%92%8C-readwrite" aria-hidden="true"><span class="octicon octicon-link"></span></a>readonly 和 readwrite</h3>

<ul>
<li> <strong>readonly</strong> ：只生成get方法，没有set方法</li>
<li> <strong>readwrite</strong>：只生成set方法 ，没有get方法</li>
</ul>

<hr>

<h3>
<a id="return" class="anchor" href="#return" aria-hidden="true"><span class="octicon octicon-link"></span></a>return</h3>

<ul>
<li>主要用于计数应用加1</li>
<li>一般是用于字符串（ NSString，NSMutableString），数组（NSMutableArray，NSArray），字典对象，视图对象（UIView ），控制器对象（UIViewController）等 
比如： 
<a href="https://github.com/property" class="user-mention">@property</a> (nonatomic,retain) NSString * myString; 
<a href="https://github.com/property" class="user-mention">@property</a> (nonatomic, retain) UIView * myView; 
<a href="https://github.com/property" class="user-mention">@property</a> (nonatomic, retain) UIViewController * myViewController; 
&gt;在使用ARC的情况下常用的指示符：当一个对象引用计数大于1时，该对象不该被回收，当使用ARC的话，一般很少用。</li>
<li>启用ARC机制：  - fobjc - arc</li>
</ul>

<hr>

<h3>
<a id="strong和-week" class="anchor" href="#strong%E5%92%8C-week" aria-hidden="true"><span class="octicon octicon-link"></span></a>strong和 week</h3>

<ul>
<li><p><strong>strong</strong> ：强引用，只要指向被赋值的对象，那么该对象就不会被自动回收。</p></li>
<li><p><strong>week</strong> ：弱引用，弱引用指向的对象，可能被回收。</p></li>
</ul>

<blockquote>
<p>什么时候用：如果不希望该属性的引用的对象被回收的话，用strong，性能低。
为了保证性能，避免内存泄漏，可以使用week，对应声明为week的指针，指针指向的地址一旦被释放，这些指针都被赋值为nil，能防止出现悬空指针。</p>
</blockquote>

<ul>
<li>事实上 （week==assign）（strong==retain）</li>
</ul>

<blockquote>
<p>注意：苹果建议使用week代替assign</p>
</blockquote>

<h4>
<a id="比如-1" class="anchor" href="#%E6%AF%94%E5%A6%82-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>比如 1</h4>

<p>1  从storyboard或者xib上创建控件，在控件放在view上的时候，已经形成了如下的引用关系,以UIButton为例：
UIViewController-&gt;UIView-&gt;subView-&gt;UIButton然后你为这个UIButton声明一个weak属性<br>
<code>@property(nonatomic,weak) IBOOutlet UIButton *btn;</code>
相当于xib/sb对这个Button是强引用，你声明的属性对它是弱引用。</p>

<p>2 手动创建控件
a). 将控件声明成strong
<code>@property(nonatomic,strong) UIButton *btn;</code>
那么你在实现这个控件时只需这样：</p>

<p><code>
_btn = [[UIButton alloc]init];
[self.view addSubview:_btn]
</code></p>

<p>b). 将控件声明成
weak@property(nonatomic,weak) UIButton *btn;
那么你在实现这个控件时需要这样：</p>

<p><code>
UIButton *button = [[UIButton alloc]init];
_btn = button;
[self.view addSubview:_btn];
</code>
有一种情况：如果label1添加到button1，label2添加到button1，而self.view addSubView button1,如果当button从父视图移除的话，label1和label2不想消失，那么就得用strong（强引用），而button用不用strong都无所谓，因为界面都消失了，要button有何用。。。。。</p>

<blockquote>
<h5>
<a id="注意nsstring一般用copy-控件类用week-复杂类型一般用strong基本数据类型nsintegerint-float一般用assign一般的赋值" class="anchor" href="#%E6%B3%A8%E6%84%8Fnsstring%E4%B8%80%E8%88%AC%E7%94%A8copy-%E6%8E%A7%E4%BB%B6%E7%B1%BB%E7%94%A8week-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E4%B8%80%E8%88%AC%E7%94%A8strong%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bnsintegerint-float%E4%B8%80%E8%88%AC%E7%94%A8assign%E4%B8%80%E8%88%AC%E7%9A%84%E8%B5%8B%E5%80%BC" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意：NSString一般用copy ，控件类用week ，复杂类型一般用Strong，基本数据类型（NSInteger，int ，float。。。。。）一般用assign（一般的赋值）</h5>
</blockquote>

<h4>
<a id="比如-2" class="anchor" href="#%E6%AF%94%E5%A6%82-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>比如 2</h4>

<pre><code>1&gt;
@property (nonatomic,strong) NSString * str1; 
@property (nonatomic,week) NSString * str2; 
_str1 = [NSMUtableString alloc]initWithString:@"杠杠滴"
_str2 = str1;
_str1 = nil;
NSLog(@"%@", str2);
//输出结果为空


2&gt;
@property (nonatomic,strong) NSString * str1; 
@property (nonatomic,strong) NSString * str2; 
_str1 = [NSMUtableString alloc]initWithString:@"杠杠滴"
_str2 = str1;
_str1 = nil;
NSLog(@"%@", _str2);
//输出结果为:杠杠滴
</code></pre>

<blockquote>
<h4>
<a id="解释" class="anchor" href="#%E8%A7%A3%E9%87%8A" aria-hidden="true"><span class="octicon octicon-link"></span></a>解释：</h4>

<p><img src="./1450627289258.png" alt="Alt text"></p>

<h4>
<a id="arc原则只要还有一个变量指向对象对象就会保持在内存中" class="anchor" href="#arc%E5%8E%9F%E5%88%99%E5%8F%AA%E8%A6%81%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AF%B9%E8%B1%A1%E5%B0%B1%E4%BC%9A%E4%BF%9D%E6%8C%81%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD" aria-hidden="true"><span class="octicon octicon-link"></span></a>ARC原则：只要还有一个变量指向对象，对象就会保持在内存中</h4>

<h4>
<a id="1week-str2虽然和str1指向同一段内存但是str2并不是拥有者所以当str1nil内存就被释放了str2也就等于nil" class="anchor" href="#1week-str2%E8%99%BD%E7%84%B6%E5%92%8Cstr1%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E6%AE%B5%E5%86%85%E5%AD%98%E4%BD%86%E6%98%AFstr2%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%8B%A5%E6%9C%89%E8%80%85%E6%89%80%E4%BB%A5%E5%BD%93str1nil%E5%86%85%E5%AD%98%E5%B0%B1%E8%A2%AB%E9%87%8A%E6%94%BE%E4%BA%86str2%E4%B9%9F%E5%B0%B1%E7%AD%89%E4%BA%8Enil" aria-hidden="true"><span class="octicon octicon-link"></span></a>1》week: str2虽然和str1指向同一段内存，但是str2并不是拥有者，所以当str1=nil，内存就被释放了，str2也就等于nil。</h4>

<h4>
<a id="2-strongstr2和str1都指向同一段内存而且都是拥有者当str1-nil-释放后str2仍然指向那块内存也就是等于杠杆的" class="anchor" href="#2-strongstr2%E5%92%8Cstr1%E9%83%BD%E6%8C%87%E5%90%91%E5%90%8C%E4%B8%80%E6%AE%B5%E5%86%85%E5%AD%98%E8%80%8C%E4%B8%94%E9%83%BD%E6%98%AF%E6%8B%A5%E6%9C%89%E8%80%85%E5%BD%93str1-nil-%E9%87%8A%E6%94%BE%E5%90%8Estr2%E4%BB%8D%E7%84%B6%E6%8C%87%E5%90%91%E9%82%A3%E5%9D%97%E5%86%85%E5%AD%98%E4%B9%9F%E5%B0%B1%E6%98%AF%E7%AD%89%E4%BA%8E%E6%9D%A0%E6%9D%86%E7%9A%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>2 》strong：str2和str1都指向同一段内存，而且都是拥有者，当str1= nil 释放后，str2仍然指向那块内存，也就是等于@“杠杆的”。</h4>
</blockquote>

<hr>

<h3>
<a id="unsafe_unretained" class="anchor" href="#unsafe_unretained" aria-hidden="true"><span class="octicon octicon-link"></span></a>unsafe_unretained</h3>

<ul>
<li>和week基本类似，与week不同的是，当unsafe_unretained指针引用的对象被回收后，unsafe_unretained不会被置为nil。
&gt;注： 一般来说，unsafe_unretuained不如week指示符</li>
</ul>

<h1>
<a id="待完善" class="anchor" href="#%E5%BE%85%E5%AE%8C%E5%96%84" aria-hidden="true"><span class="octicon octicon-link"></span></a>&gt;待完善。。。。。</h1>

<p>xx</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
